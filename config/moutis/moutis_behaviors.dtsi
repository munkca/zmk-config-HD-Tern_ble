/*
 * moutis_behaviors.dtsi
 *
 * SPDX-License-Identifier: MIT
 *
 */
 

#define     my_hrm_config \
            compatible = "zmk,behavior-hold-tap"; \
            #binding-cells = <2>; \
            flavor = "balanced"; \
            hold-trigger-on-release; \
            tapping-term-ms = <my_tapping_term>; \
            quick-tap-ms = <my_quick_tapping_term>

#define     my_lt_config \
            compatible = "zmk,behavior-hold-tap"; \
            #binding-cells = <2>; \
            flavor = "tap-preferred"; \
            hold-trigger-on-release; \
            hold-while-undecided-linger; \
            tapping-term-ms = <my_tapping_term>; \
            quick-tap-ms = <my_quick_tapping_term>

#define     my_lk_config \
            compatible = "zmk,behavior-hold-tap"; \
            #binding-cells = <2>; \
            tapping-term-ms = <my_tapping_term>; \
            flavor = "tap-preferred"

        skapp: sticky_key_app_switcher {
            compatible = "zmk,behavior-sticky-key";
            #binding-cells = <1>;
            bindings = <&kp>;
            release-after-ms = <900>;
        };

#define rst_btld reset_bootldr 0 0 // simple macro to keep the keymap uncluttered
         reset_bootldr: reset_bootldr { // tap for reset, hold for bootloader
            compatible = "zmk,behavior-hold-tap";
            #binding-cells = <2>;
            tapping-term-ms = <500>;    // hold 0.5 seconds (Nice!Nano double-tap reset timing)
            flavor = "tap-preferred";
            bindings = <&bootloader>, <&sys_reset>;
        };

//
// home row mods
//

        hm: homerow_mods { // use on either hand
            my_hrm_config;
            bindings = <&kp>, <&kp>;
        };
        hmr: homerow_mods_right { // use on right hand to mod left
            my_hrm_config;
            bindings = <&kp>, <&kp>;
            hold-trigger-key-positions = <KEYS_L THUMBS>; // left hand allowed
        };
        hml: homerow_mods_left { // use on left hand to mod right
            my_hrm_config;
            bindings = <&kp>, <&kp>;
            hold-trigger-key-positions = <KEYS_R THUMBS>; // right hand allowed
        };
//
// maybe should be separated? but here for now...
//
// these because we can't use macro/behavior in mt parameter?
//
        mt_S: mt_S {
            my_hrm_config;
            bindings = <&kp>, <&ak_S>;
            hold-trigger-key-positions = <KEYS_R THUMBS>; // right hand allowed
        };
        mt_C: mt_C {  // C is on RIGHT hand in Pm, so it has no restriction
            my_hrm_config;
            bindings = <&kp>, <&ak_C>;
//            hold-trigger-key-positions = <KEYS_R THUMBS>; // right hand allowed
        };
        mt_N: mt_N {
            my_hrm_config;
            bindings = <&kp>, <&ak_N>;
            hold-trigger-key-positions = <KEYS_R THUMBS>; // right hand allowed
        };
        mt_T: mt_T {
            my_hrm_config;
            bindings = <&kp>, <&ak_T>;
            hold-trigger-key-positions = <KEYS_R THUMBS>; // right hand allowed
        };
        mt_D: mt_D {  // Onldy AU (Gold) has D on home
            my_hrm_config;
            bindings = <&kp>, <&ak_D>;
            hold-trigger-key-positions = <KEYS_R THUMBS>; // right hand allowed
        };
        mt_A: mt_A {
            my_hrm_config;
            bindings = <&kp>, <&ak_A>;
            hold-trigger-key-positions = <KEYS_L THUMBS>; // left hand allowed
       };
        mt_E: mt_E {
            my_hrm_config;
            bindings = <&kp>, <&ak_E>;
            hold-trigger-key-positions = <KEYS_L THUMBS>; // left hand allowed
        };
        mt_I: mt_I {
            my_hrm_config;
            bindings = <&kp>, <&ak_I>;
            hold-trigger-key-positions = <KEYS_L THUMBS>; // left hand allowed
        };
        mt_H: mt_H {
            my_hrm_config;
            bindings = <&kp>, <&ak_H>;
            hold-trigger-key-positions = <KEYS_L THUMBS>; // right hand allowed
        };
        mt_M: mt_M {        // M on right pinky in Rhodium
            my_hrm_config;
            bindings = <&kp>, <&ak_M>;
            hold-trigger-key-positions = <KEYS_L THUMBS>; // left hand allowed
        };
        lt_R: lt_R {
            my_lt_config;
            bindings = <&mo>, <&ak_R>;
        };
        lt_BSPC: lt_BSPC {
            my_lt_config;
            bindings = <&mo>, <&mm_BspcDel>;
        };

/*
 * modmorph behaviors
 * identified by the camel case of each of the keycodes
 */
        DotColn: DotColn {
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&ak_DOT>, <&kp COLON>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
        DotColnJ: DotColnJ { // no adaptive Japanese
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&kp DOT>, <&kp COLON>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
        SlshStar: SlshStar {  // shift = *, alt = backslash
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&SlshBslh>, <&kp STAR>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
        SlshBslh: SlshBslh {
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&kp FSLH>, <&kp BSLH>;
            mods = <(MOD_LALT|MOD_RALT)>;
        };
        SlshStarJ: SlshStarJ { // no adaptive Japanese
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&kp FSLH>, <&kp STAR>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
        HashDllr: HashDllr {
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&ak_HASH>, <&kp DLLR>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
        MinusPlus: MinusPlus {
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&kp MINUS>, <&kp PLUS>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };

/*
 * &DqtLT (put just this in the keymap)
 *
 * Double Quote key behaviors:
 *      tap     = " double quote
 *      shift   = < (less than)
 *      alt     = « (French quote double chevron)
 *      linger  = paired symbols w/insertion point between
 *
 * &SqtGT is the corresponding behavior.
 *
 * This set is used when the " appears to the left of ' in the keymap
 * so the paired symbols <«  »> are spacially correct.
 *
 * To use, just put &DqtLT in the keymap. The other behaviors are
 * so the paired symbols <«  »> are spacially correct.
 *
 */
 
#define DqtLT lkDqt_lkLT 0 0    // simple macros to keep the keymap uncluttered
#define SqtGT lkSqt_GT 0 0      // simply put &DqtLT or &SqtGT in the keymap

        lkDqt_lkLT: lkDqt_lkLT {            // Hold for paired symbols
            my_lk_config;
            bindings = <&pairDquotLT>, <&leftDquotLT>;
        };
        pairDquotLT: pairDquotLT {          // SHFT for <>
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&pairDquotDchev>, <&t_pairLtGt>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
        pairDquotDchev: pairDquotDchev {    // "" or ALT for «»
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&t_pairDquo>, <&t_pairDchev>;
            mods = <(MOD_LALT|MOD_RALT)>;
        };
        leftDquotLT: leftDquotLT {          // SHFT for <
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&leftDquotChev>, <&kp LT>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
        leftDquotChev: leftDquotLChev {     // " or ALT for «
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&ak_DQT>, <&kp LDCHEV>;
            mods = <(MOD_LALT|MOD_RALT)>;
        };

        lkSqt_GT: lkSqt_GT {                // Hold for paired ’’
            my_lk_config;
            bindings = <&pairSquotGT>, <&rightSquotGT>;
        };
        pairSquotGT: pairSquotGT {          // SHIFT = >
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&pairSquotChev>, <&kp GT>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
        pairSquotChev: pairSquotChev {          // ALT = »
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&t_pairSquo>, <&kp RDCHEV>;
            mods = <(MOD_LALT|MOD_RALT)>;
        };
        rightSquotGT: rightSquotGT {          // SHIFT = >
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&SqtRchev>, <&kp GT>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
        SqtRchev: SqtRchev {                // ' or ALT = »
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&ak_SQT>, <&kp RDCHEV>;
            mods = <(MOD_LALT|MOD_RALT)>;
        };
/*
 * end of Double Quote key behaviors
 */

/*
 * &SqtLT (put just this in the keymap)
 *
 * Single Quote key behaviors:
 *      tap     = ' single quote
 *      shift   = < (less than)
 *      alt     = « (French quote double chevron)
 *      linger  = paired symbols w/insertion point between
 *
 * &DqtGT is the corresponding behavior.
 *
 * This set is used when the ' appears to the left of " in the keymap
 * so the paired symbols <«  »> are spacially correct. (i.e. Rhodium)
 *
 * To use, just put &SqtLT in the keymap. The other behaviors are
 * referenced by this one.
 *
 */
 
#define SqtLT lkSqt_lkLT 0 0    // simple macros to keep the keymap uncluttered
#define DqtGT lkDqt_GT 0 0      // simply put &SqtLT or &DqtGT in the keymap

        lkSqt_lkLT: lkSqt_lkLT {            // Hold for paired symbols
            my_lk_config;
            bindings = <&pairSquotLT>, <&leftSquotLT>;
        };
        pairSquotLT: pairSquotLT {          // SHFT for <>
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&pairSquotDchev>, <&t_pairLtGt>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
        pairSquotDchev: pairSquotDchev {    // '' or ALT for «»
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&t_pairSquo>, <&t_pairDchev>;
            mods = <(MOD_LALT|MOD_RALT)>;
        };
        leftSquotLT: leftSquotLT {          // SHFT for <
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&leftSquotChev>, <&kp LT>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
        leftSquotChev: leftSquotLChev {     // ' or ALT for «
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&kp LT>, <&kp LDCHEV>;
            mods = <(MOD_LALT|MOD_RALT)>;
        };

        lkDqt_GT: lkDqt_GT {                // Hold for paired “”
            my_lk_config;
            bindings = <&pairDquotGT>, <&rightDqtGT>;
        };
        pairDquotGT: pairDquotGT {          // SHIFT = >
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&pairDquotChev>, <&kp GT>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
        pairDquotChev: pairDquotChev {          // ALT = »
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&t_pairDquo>, <&kp RDCHEV>;
            mods = <(MOD_LALT|MOD_RALT)>;
        };
        rightDqtGT: leftDqtGT {              // SHIFT = >
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&DqtRchev>, <&kp GT>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
        DqtRchev: DqtRchev {                // " or ALT = »
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&ak_DQT>, <&kp RDCHEV>;
            mods = <(MOD_LALT|MOD_RALT)>;
        };
/*
 * end of Single Quote key behaviors
 */

        mm_BspcDel: mm_BspcDel { // layer-tap mod-morph
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&ak_BSPC>, <&kp DELETE>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
        ak_BSPC: ak_BSPC {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp BSPC>;

            ak_BSPC_U { trigger-keys = <A>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp U>; };
            ak_BSPC_A { trigger-keys = <U>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp A>; };
            ak_BSPC_O { trigger-keys = <E>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp O>; };
            ak_BSPC_E { trigger-keys = <O>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp E>; };
        };

        ak_DOT: ak_DOT {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&sl_dot>;

            ak_DOT_EXCL { trigger-keys = <FSLH>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp BSPC  &kp EXCL>; };
        };
        ak_FSLH: ak_FSLH {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp FSLH>;

            ak_FSLH_U { trigger-keys = <A>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp U>; };
        };
        ak_DQT: ak_DQT {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp DQT>;

            ak_DQT_Q { trigger-keys = <FSLH>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp BSPC  &kp QMARK>; };
        };
        ak_SQT: ak_SQT {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp SQT>;

            ak_SQT_Q { trigger-keys = <FSLH>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp BSPC  &kp S_INVQ>; };
            ak_SQT_A { trigger-keys = <U>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp A>; };
            ak_SQT_U { trigger-keys = <A>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp U>; };
        };
        ak_HASH: ak_HASH {
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp HASH>;

        ak_HASH_INVX { trigger-keys = <FSLH>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp BSPC &kp S_INVX>; };
        ak_HASH_b_Gratefully { trigger-keys = <G>; max-prior-idle-ms = <my_ak_term>; bindings = <&b_Gratefully>; };
        ak_HASH_b_Indiana { trigger-keys = <I>; max-prior-idle-ms = <my_ak_term>; bindings = <&b_Indiana>; };
        ak_HASH_b_University { trigger-keys = <U>; max-prior-idle-ms = <my_ak_term>; bindings = <&b_University>; };
        ak_HASH_b_Bloomington { trigger-keys = <B>; max-prior-idle-ms = <my_ak_term>; bindings = <&b_Bloomington>; };
        };


/*
 *  &CommaMagic (put just this in the keymap)
 *
 *  Then you'll need to add an behavior-adaptive-key for every alpha in place of
 *  the alpha. For example:
 *
 *  instead of &KP A in the keymap, use &ak_A and a behavior def:
 *
 *      ak_A: ak_A {
 *          compatible = "zmk,behavior-adaptive-key";
 *          #binding-cells = <0>;
 *          bindings = <&kp A>;
 *          akA_Cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC &kp LS(A)>; };
 *      };
 *
 *  It works flawlessly for me. Your mileage may vary
 */
#define CommaMagic CmmaMgc CAPSLOCK 0   // simple macro to keep the keymap uncluttered

        CmmaMgc: CmmaMgc {  // Hold for CAPSLOCK, tap for COMMA
            my_lk_config;
            bindings = <&kp>, <&CmmaSemi>;
        };
        CmmaSemi: CmmaSemi { // press = COMMA,shift = Semicolon
            compatible = "zmk,behavior-mod-morph";
            #binding-cells = <0>;
            bindings = <&ak_CMMA>, <&kp SEMI>;
            mods = <(MOD_LSFT|MOD_RSFT)>;
        };
        ak_CMMA: ak_CMMA { // double-tap comma = caps_word
            compatible = "zmk,behavior-adaptive-key";
            #binding-cells = <0>;
            bindings = <&kp CMMA>;
            ak_CMMA_cap { trigger-keys = <CMMA>; max-prior-idle-ms = <my_cc_term>; bindings = <&kp BSPC  &caps_word>; };
        // optional alt fingering to eliminate SFBs in vowel block on HD Neu layout variations
            ak_CMMA_O { trigger-keys = <E>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp O>; };
            ak_CMMA_E { trigger-keys = <O>; max-prior-idle-ms = <my_ak_term>; bindings = <&kp E>; };
        };

/*
 * lk_ linger key behaviors (approximated via hold-tap)
 * most require a combo to execute the multiple key taps
 */
        lk: lk {    // a generic linger behavior
            my_lk_config;
            bindings = <&kp>, <&kp>;
        };

        lk_qu: lk_qu {
            my_lk_config;
            bindings = <&kp>, <&t_Qu>;
        };

#define lk_LRDquote lk_Dquot RBRC LBRC   // simply put &lk_LRDquote in the keymap
        lk_Dquot: lk_Dquot {            // " on tap, “” on "linger" (curly quotes)
            my_lk_config;
            bindings = <&t_pairDquo>, <&kp>;
        };
#define lk_LRpar lk_par RPAR LPAR       // simply put &lk_LRpar in the keymap
        lk_par: lk_par {                // ( on tap, () on "linger"
            my_lk_config;
            bindings = <&t_pairPar>, <&kp>;
        };
#define lk_LRbkt lk_bkt RBKT LBKT       // simply put &lk_LRbkt in the keymap
        lk_bkt: lk_bkt {                // [ on tap, [] on "linger"
            my_lk_config;
            bindings = <&t_pairBkt>, <&kp>;
        };
#define lk_LRbrc lk_brc RBRC LBRC       // simply put &lk_LRbrc in the keymap
        lk_brc: lk_brc {                //
            my_lk_config;
            bindings = <&t_pairBrc>, <&kp>;
        };
#define lk_LRltgt lk_ltgt GT LT         // simply put &lk_LRltgt in the keymap
        lk_ltgt: lk_ltgt {              // < on tap, <|> on "linger"
            my_lk_config;
            bindings = <&t_pairLtGt>, <&kp>;
        };
#define lk_LRques lk_QMARK S_INVQ QMARK // simply put &lk_LRques in the keymap
        lk_QMARK: lk_QMARK {            // ¿ on tap, ¿|? on "linger"
            my_lk_config;
            bindings = <&t_pairQmark>, <&kp>;
        };
#define lk_LRexcl lk_EXCL S_INVX EXCL   // simply put &lk_LRexcl in the keymap
        lk_EXCL: lk_EXCL {              // ¡ on tap, ¡|! on "linger"
            my_lk_config;
            bindings = <&t_pairExcl>, <&kp>;
        };

        lk_E_accent: lk_E_accent { // ´, é on "linger"
            my_lk_config;
            bindings = <&t_Eaccent>, <&kp>;
        };
        lk_E_grave: lk_E_grave { // `, è on "linger"
            my_lk_config;
            bindings = <&t_Egrave>, <&kp>;
        };
        lk_E_acute: lk_E_acute { // ˆ, ê on "linger"
            my_lk_config;
            bindings = <&t_Eacute>, <&kp>;
        };
        lk_O_macron: lk_O_macron { // ¯, ō on "linger"
            my_lk_config;
            bindings = <&t_Omacron>, <&kp>;
        };
        lk_A_ring: lk_A_ring { // ˚, å on "linger"
            my_lk_config;
            bindings = <&t_Aring>, <&kp>;
        };
        lk_U_umlaut: lk_U_umlaut { // ¨, ü on "linger"
            my_lk_config;
            bindings = <&t_Uumlaut>, <&kp>;
        };
        lk_C_cedille: lk_C_cedille { // ¸, ç on "linger"
            my_lk_config;
            bindings = <&t_Cedille>, <&kp>;
        };

        lk_th: lk_th { // Th on tap, tion on "linger"
            my_lk_config;
            bindings = <&t_tion>, <&t_Th>;
        };
        lk_sh: lk_sh { // Sh on tap, sion on "linger"
            my_lk_config;
            bindings = <&t_sion>, <&t_Sh>;
        };
        lk_gh: lk_gh { // Gh on tap, Ght on "linger"
            my_lk_config;
            bindings = <&t_ght>, <&t_Gh>;
        };


/*
 *
 * Three finger text macros (tap & hold varieties)
 *
 */
    lk_L_textE: lk_L_textE { //
            my_lk_config;
            bindings = <&t_LHoldE>, <&t_LTapE>;
    };
    lk_R_textE: lk_R_textE { //
            my_lk_config;
            bindings = <&t_RHoldE>, <&t_RTapE>;
    };
#ifdef JP_MODE_ENABLE
    lk_L_textJ: lk_L_textJ { //
            my_lk_config;
            bindings = <&t_LHoldJ>, <&t_LTapJ>;
    };
    lk_R_textJ: lk_R_textJ { //
            my_lk_config;
            bindings = <&t_RHoldJ>, <&t_RTapJ>;
    };
#endif

