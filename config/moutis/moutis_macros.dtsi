/*
 * moutis_macros.dtsi
 *
 * SPDX-License-Identifier: MIT
 *
 * t_  = type text
 * b_  = backspace then type text (often for "adaptive key")
 * m_  = macro (performs commands/behaviors, incl. typing).
 * ak_ = type a letter as an adaptive key (consider the prior key).
 *
 */
 
 //
 // What am I doing wrong here? This doesn't seem to work. Why?
 // copying all these into the macro def works, but no as a
 // preprocessor macro? What gives?
 //
 #define RELEASE_ALL_MODS <&macro_release &kp LSHFT> \
                        , <&macro_release &kp RSHFT> \
                        , <&macro_release &kp LALT> \
                        , <&macro_release &kp RALT> \
                        , <&macro_release &kp LCTL> \
                        , <&macro_release &kp RCTL> \
                        , <&macro_release &kp LGUI> \
                        , <&macro_release &kp RGUI> 


     ZMK_MACRO(m_alpha,
        bindings =
            <&kp LANG2>,    // switch to Roman/Latin script (m_henk/latin)
            <&to l_hd>;     // make alpha layer default
       )
     ZMK_MACRO(m_japan,
        bindings =
            <&kp LANG1>,    // switch to Japanese script (henk/kana/romaji)
            <&to l_jp>;     // make Japanese layer default
       )

/*
 *
 * App switcher "SlAppy" & "SlApBack"
 * holds up the app menu, allows L/R navigation
 *
 */

   ZMK_MACRO(SlAppy,        // "Sticky Layer App Switcher"
        wait-ms = <50>; tap-ms = <20>;
        bindings =
                  <&macro_press &kp RGUI>    // leave GUI down to keep menu up
                , <&macro_tap &kp TAB>       // (use press for repeat)
                , <&tog l_nav>               // to navigate the app menu
                , <&macro_pause_for_release> // hold to keep menu up or for repeat ...
                , <&tog l_nav>               // done navigating
                , <&macro_tap &skapp LGUI>   // release other GUI after a timeout
                , <&macro_release &kp RGUI>  // release the previous hold
                ;
        )
    ZMK_MACRO(SlApBack,        // "Sticky Layer App Switcher Backwards"
        wait-ms = <50>; tap-ms = <20>;
        bindings =
                  <&macro_press &sk RGUI>     // leave GUI down to keep menu up
                , <&macro_press &kp LSHFT>    //
                , <&macro_tap &kp TAB>        // just tap for no repeat
                , <&macro_pause_for_release>  // hold for repeat ...
                , <&macro_release &kp LSHFT>  //
                , <&macro_tap &skapp LGUI>    // release other GUI after a timeout
                , <&macro_release &sk RGUI>   // now release the previous hold
                ;
        )

    ZMK_MACRO(m_numword,
        tap-ms = <my_tapping_speed>;
        bindings =  <&num_word l_fun>
                ;
        )

/*
 *
 * basic editing macros
 *
 */

    ZMK_MACRO(m_selword,
        tap-ms = <my_tapping_speed>;
        bindings =  <&macro_tap &kp LA(LEFT)>
                , <&macro_tap &kp LS(LA(RIGHT))>
                ;
        )
    ZMK_MACRO(m_findsel,
        tap-ms = <my_tapping_speed>;
        bindings =  <&macro_tap &kp LG(C)>
                , <&macro_tap &kp LG(F)>
                , <&macro_tap &kp LG(V)>
                , <&macro_tap &kp RETURN>
                , <&macro_tap &kp LG(G)>
                ;
        )

/*
 *
 * paired symbols [({<« “‘|’” »>})]
 * leaving insertion point between
 *
 */

    ZMK_MACRO(t_pairDquo,   // type "" put insertion between
        tap-ms = <my_tapping_speed>;
        bindings =  <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_release &kp LALT>
                , <&macro_release &kp RALT>
                , <&macro_release &kp LCTL>
                , <&macro_release &kp RCTL>
                , <&macro_release &kp LGUI>
                , <&macro_release &kp RGUI>
                , <&macro_tap &kp LDQUO>
                , <&macro_tap &kp RDQUO>
                , <&macro_tap &kp LEFT>
                ;
        )
    ZMK_MACRO(t_pairSquo,   // type '' put insertion between
        tap-ms = <my_tapping_speed>;
        bindings =  <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_release &kp LALT>
                , <&macro_release &kp RALT>
                , <&macro_release &kp LCTL>
                , <&macro_release &kp RCTL>
                , <&macro_release &kp LGUI>
                , <&macro_release &kp RGUI>
                , <&macro_tap &kp LSQUO>
                , <&macro_tap &kp RSQUO>
                , <&macro_tap &kp LEFT>
                ;
        )
    ZMK_MACRO(t_pairLtGt,   // type <> put insertion between
        tap-ms = <my_tapping_speed>;
        bindings =  <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_release &kp LALT>
                , <&macro_release &kp RALT>
                , <&macro_release &kp LCTL>
                , <&macro_release &kp RCTL>
                , <&macro_release &kp LGUI>
                , <&macro_release &kp RGUI>
                , <&macro_tap &kp LT>
                , <&macro_tap &kp GT>
                , <&macro_tap &kp LEFT>
                ;
        )
    ZMK_MACRO(t_pairPar,    // type () put insertion between
        tap-ms = <my_tapping_speed>;
        bindings =  <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_release &kp LALT>
                , <&macro_release &kp RALT>
                , <&macro_release &kp LCTL>
                , <&macro_release &kp RCTL>
                , <&macro_release &kp LGUI>
                , <&macro_release &kp RGUI>
                , <&macro_tap &kp LPAR>
                , <&macro_tap &kp RPAR>
                , <&macro_tap &kp LEFT>
                ;
        )
    ZMK_MACRO(t_pairBrc,    // type {} put insertion between
        tap-ms = <my_tapping_speed>;
        bindings =  <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_release &kp LALT>
                , <&macro_release &kp RALT>
                , <&macro_release &kp LCTL>
                , <&macro_release &kp RCTL>
                , <&macro_release &kp LGUI>
                , <&macro_release &kp RGUI>
                , <&macro_tap &kp LBRC>
                , <&macro_tap &kp RBRC>
                , <&macro_tap &kp LEFT>
                ;
        )
    ZMK_MACRO(t_pairBkt,    // type [] put insertion between
        tap-ms = <my_tapping_speed>;
        bindings =  <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_release &kp LALT>
                , <&macro_release &kp RALT>
                , <&macro_release &kp LCTL>
                , <&macro_release &kp RCTL>
                , <&macro_release &kp LGUI>
                , <&macro_release &kp RGUI>
                , <&macro_tap &kp LBKT>
                , <&macro_tap &kp RBKT>
                , <&macro_tap &kp LEFT>
                ;
        )
    ZMK_MACRO(t_pairDchev,  // type «  » put insertion between
        tap-ms = <my_tapping_speed>;
        bindings =  <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_release &kp LALT>
                , <&macro_release &kp RALT>
                , <&macro_release &kp LCTL>
                , <&macro_release &kp RCTL>
                , <&macro_release &kp LGUI>
                , <&macro_release &kp RGUI>
                , <&macro_tap &kp LDCHEV>
                , <&macro_tap &kp SPC>
                , <&macro_tap &kp RDCHEV>
                , <&macro_tap &kp LEFT>     // avoid dbl space interpreting by host
                , <&macro_tap &kp SPC>
                , <&macro_tap &kp LEFT>
                ;
        )
    ZMK_MACRO(t_pairSchev,  // type ‹  › put insertion between
        tap-ms = <my_tapping_speed>;
        bindings =  <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_release &kp LALT>
                , <&macro_release &kp RALT>
                , <&macro_release &kp LCTL>
                , <&macro_release &kp RCTL>
                , <&macro_release &kp LGUI>
                , <&macro_release &kp RGUI>
                , <&macro_tap &kp LSCHEV>
                , <&macro_tap &kp SPC>
                , <&macro_tap &kp LEFT>     // avoid dbl space interpreting by host
                , <&macro_tap &kp SPC>
                , <&macro_tap &kp RSCHEV>
                , <&macro_tap &kp LEFT>
                ;
        )
    ZMK_MACRO(t_pairQmark,    // type ¿? put insertion between
        tap-ms = <my_tapping_speed>;
        bindings =  <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_release &kp LALT>
                , <&macro_release &kp RALT>
                , <&macro_release &kp LCTL>
                , <&macro_release &kp RCTL>
                , <&macro_release &kp LGUI>
                , <&macro_release &kp RGUI>
                , <&macro_tap &kp S_INVQ>
                , <&macro_tap &kp QUOT>
                , <&macro_tap &kp LEFT>
                ;
        )
    ZMK_MACRO(t_pairExcl,    // type ¡! put insertion between
        tap-ms = <my_tapping_speed>;
        bindings =  <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_release &kp LALT>
                , <&macro_release &kp RALT>
                , <&macro_release &kp LCTL>
                , <&macro_release &kp RCTL>
                , <&macro_release &kp LGUI>
                , <&macro_release &kp RGUI>
                , <&macro_tap &kp S_INVX>
                , <&macro_tap &kp EXCL>
                , <&macro_tap &kp LEFT>
                ;
        )

    ZMK_MACRO(sl_dot,
        bindings = <&macro_tap &kp DOT>
                , <&sl l_akDot>
                ;
        )

    ZMK_MACRO(sl_P,
        bindings = <&macro_tap &kp P>
                , <&sl l_akDot>
                ;
        )
    ZMK_MACRO(sl_L,
        bindings = <&macro_tap &kp L>
                , <&sl l_akDot>
                ;
        )
    ZMK_MACRO(sl_M,
        bindings = <&macro_tap &kp M>
                , <&sl l_akDot>
                ;
        )

    ZMK_MACRO(t_Qu,
        tap-ms = <my_tapping_speed>;
        bindings = <&ak_Q>
                , <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_tap &kp U>
                ;
        )
    ZMK_MACRO(t_Semi,
        tap-ms = <my_tapping_speed>;
        bindings = <&macro_release &kp LSHFT>
                , <&macro_tap &kp SEMICOLON>
                ;
        )
/*
 *
 * accented chars (evetually move to Semantic Keys)
 *
 */
    ZMK_MACRO(t_Eaccent,
        tap-ms = <my_tapping_speed>;
        bindings = <&kp LA(E) &kp E>
                ;
        )
    ZMK_MACRO(t_Egrave,
        tap-ms = <my_tapping_speed>;
        bindings = <&kp LA(GRAVE) &kp E>
                ;
        )
    ZMK_MACRO(t_Eacute,
        tap-ms = <my_tapping_speed>;
        bindings = <&kp LA(N6) &kp E>
                ;
        )
    ZMK_MACRO(t_Omacron,
        tap-ms = <my_tapping_speed>;
        bindings = <&kp LA(A) &kp O>
                ;
        )
    ZMK_MACRO(t_Aring,
        tap-ms = <my_tapping_speed>;
        bindings = <&kp LA(K) &kp A>
                ;
        )
    ZMK_MACRO(t_Uumlaut,
        tap-ms = <my_tapping_speed>;
        bindings = <&kp LA(U) &kp U>
                ;
        )
    ZMK_MACRO(t_Cedille,
        tap-ms = <my_tapping_speed>;
        bindings = <&kp LA(C) &kp C>
                ;
        )
    ZMK_MACRO(t_pg,
        tap-ms = <my_tapping_speed>;
        bindings = <&kp P &kp G>;
        )
    ZMK_MACRO(b_wd,
        tap-ms = <my_tapping_speed>;
        bindings = <&kp BSPC &kp W &kp D>;
        )
    ZMK_MACRO(t_dotcom,
        wait-ms = <50>; // need to slow this down for some systems.
        bindings = <&kp C &kp O &kp M>
                ;
        )
    ZMK_MACRO(t_dotedu,
        wait-ms = <50>; // need to slow this down for some systems.
        bindings = <&kp E &kp D &kp U>
                ;
        )
    ZMK_MACRO(t_dotorg,
        wait-ms = <50>; // need to slow this down for some systems.
        bindings = <&kp O &kp R &kp G>
                ;
        )

/*
 *
 * Three finger text macros (tap & hold varieties)
 *
 */
 
    ZMK_MACRO(t_LTapE,
        tap-ms = <(my_tapping_speed / 2)>;
        bindings = <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_tap &kp A &kp L &kp A &kp N &kp R &kp E &kp I &kp S &kp E &kp R &kp DOT &kp C &kp O &kp M>
                ;
        )
    ZMK_MACRO(t_LHoldE,  // demonstrate what's possible w/macros
        tap-ms = <(my_tapping_speed / 2)>;
        bindings = <&kp LS(E)>
                , <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_tap &kp N &kp D &kp SPACE>
                , <&macro_tap &kp O &kp F &kp SPACE>
                , <&macro_tap &kp T &kp I &kp M &kp E &kp S &kp SPACE>
                , <&macro_tap &kp I &kp N &kp SPACE>
                , <&macro_tap &kp N2 &kp N0 &kp N2 &kp N0 &kp RETURN>
                ;
        )
    ZMK_MACRO(t_RTapE,
        tap-ms = <(my_tapping_speed / 2)>;
        bindings = <&kp LS(J)>
                , <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_tap &kp A &kp P &kp A &kp N>
                ;
        )
    ZMK_MACRO(t_RHoldE,
        tap-ms = <(my_tapping_speed / 2)>;
        bindings = <&kp LS(J)>
                , <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_tap &kp A &kp P &kp A &kp N &kp E &kp S &kp E &kp SPACE>
                ;
        )
    ZMK_MACRO(b_Gratefully,
        tap-ms = <(my_tapping_speed / 2)>;
        bindings = <&kp BSPC &kp LS(G)>
                , <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_tap &kp R &kp A &kp T &kp E &kp F &kp U &kp L &kp L &kp Y &kp CMMA &kp SPACE>
                ;
        )
    ZMK_MACRO(b_Indiana,
        tap-ms = <(my_tapping_speed / 2)>;
        bindings = <&kp BSPC &kp LS(I)>
                , <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_tap &kp N &kp D &kp I &kp A &kp N &kp A>
                ;
        )
    ZMK_MACRO(b_University,
        tap-ms = <(my_tapping_speed / 2)>;
        bindings = <&kp BSPC &kp LS(U)>
                , <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_tap &kp N &kp I &kp V &kp E &kp R &kp S &kp I &kp T &kp Y>
                ;
        )
    ZMK_MACRO(b_Bloomington,
        tap-ms = <(my_tapping_speed / 2)>;
        bindings = <&kp BSPC &kp LS(B)>
                , <&macro_release &kp LSHFT>
                , <&macro_release &kp RSHFT>
                , <&macro_tap &kp L &kp O &kp O &kp M &kp I &kp N &kp G &kp T &kp O &kp N>
                ;
        )


#ifdef H_DIGRAPH_COMBOS                 // H-digraphs? (Th, Ch, Wh, Sh, Gh, Ph)
#include "moutis_m_h_digraph.dtsi"
#endif // H_DIGRAPH_COMBOS

#ifdef EN_PRONOUN_COMBOS                // Pronoun macros?
#include "moutis_m_pronoun.dtsi"

#endif // EN_PRONOUN_COMBOS
#ifdef JP_MODE_ENABLE                   // Japanese macros?
#include "moutis_m_japanese.dtsi"
#endif // JP_MODE_ENABLE

